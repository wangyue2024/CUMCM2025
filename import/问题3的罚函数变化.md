您提供的日志非常清晰，直指了问题的核心，这说明我们的调试方向完全正确。您遇到的情况是高级优化中非常典型的“陷阱”，我们离成功只差最后一步。

您的分析完全正确：

1. **问题二**的解是 `0.0000`，说明优化器根本没有找到任何有收益的区域，直接在“无效区”收敛了。
2. **问题三**的解是 `-100.0000`，说明优化器从头到尾都在处理违反约束的解，完全被高额的惩罚“困住”了。

下面，我们来分析这两个问题的根源，并给出能够根治它们的、更高级的解决方案。

---

### **问题根源诊断**

#### **1. 问题二：奖励塑造失效——“气味”太微弱**

* **原因**：在 `cost_function_q2`中，当遮蔽时间为0时，我们返回 `REWARD_SHAPING_PENALTY_FACTOR * proxy_cost`。我之前设置的 `1e-7`这个因子**数量级太小了**。`proxy_cost`（即 `min(P(t))`）本身可能是一个很大的数值，但乘以 `1e-7`后，对于优化器来说，整个“无效区”的成本值都极其接近于0。这就像一片平坦的沙漠，优化器闻不到任何“绿洲”的方向，于是随便找个地方就“躺平”了。
* **结论**：我们需要**显著增大**这个惩罚因子，让优化器能清晰地感知到“虽然都是0秒遮蔽，但这个解比那个解更有希望”。

#### **2. 问题三：约束诅咒——在“雷区”里寸步难行**

* **原因**：这是更深层次的问题。我们对 `t1, t2, t3`进行了正规化，优化器在 `[0,1]`空间里随机生成 `x_norm_t1, x_norm_t2, x_norm_t3`。这些随机数几乎**没有任何可能**恰好满足解码后 `t2 >= t1 + 1.0`且 `t3 >= t2 + 1.0`。因此，优化器生成的**第一代种群几乎全部都是无效解**，全部收到 `100`的惩罚。它完全不知道该往哪个方向走才能“排雷”，最终只能在雷区里随便找个地方收敛。
* **结论**：用惩罚函数处理这种强相关的变量约束（`t_i`依赖 `t_{i-1}`）效率极低。我们必须采用一种更先进的技术：**“约束保持”参数化 (Constraint-Preserving Parameterization)**。

---

### **解决方案：两大根本性改进**

我们将对代码进行两项关键的、根本性的修正。

#### **修正一 (针对问题二和三)：增强奖励塑造**

我们将把惩罚因子调整到一个更合理的数量级。

**请修改 `config.py`:**

```python
# config.py

# ... (其他部分不变) ...
class Config:
    # ...
    # 【关键修正】将惩罚因子增大1000倍，让优化器能“闻到”正确的方向
    REWARD_SHAPING_PENALTY_FACTOR = 1e-4
```

#### **修正二 (针对问题三)：引入“约束保持”参数化**

这是解决问题三的核心。我们不再直接优化 `t1, t2, t3`，而是优化它们的**增量**，从而在数学上保证约束永远被满足。

* **旧方法 (易失败)**: 优化 `t1, t2, t3`，然后检查 `t2 >= t1+1` ...
* **新方法 (必成功)**:
  1. 优化一个基础投放时间 `t_start`。
  2. 优化一个时间增量 `delta_12` (从 `t1`到 `t2`的额外时长)。
  3. 优化另一个时间增量 `delta_23` (从 `t2`到 `t3`的额外时长)。
  4. 在代价函数内部，按如下方式**构造**实际的投放时间：
     * `t1 = t_start`
     * `t2 = t1 + MIN_LAUNCH_INTERVAL + delta_12`
     * `t3 = t2 + MIN_LAUNCH_INTERVAL + delta_23`

这样，只要 `delta_12`和 `delta_23`的下界是0，构造出的 `t1, t2, t3`就**永远满足**最小间隔约束！优化器可以自由地在无惩罚的有效空间内进行搜索。

---

### **重构后的 `problem_solvers.py` (V3)**

下面是应用了新策略的最终版求解器。

```python
# problem_solvers.py (V3 - Constraint-Preserving & Enhanced Reward)

import numpy as np
import cma
from config import Config
from analytical_model import PhysicsModelAnalytical

# ===================================================================
# CostFunctionWrapper 保持不变
# ===================================================================
class CostFunctionWrapper:
    def __init__(self, cost_function, lower_bounds, upper_bounds):
        self.cost_function = cost_function
        self.lower = np.array(lower_bounds)
        self.upper = np.array(upper_bounds)
        self.range = self.upper - self.lower

    def __call__(self, x_norm: np.ndarray) -> float:
        x_norm_clipped = np.clip(x_norm, 0, 1)
        x_physical = self.lower + x_norm_clipped * self.range
        return self.cost_function(x_physical)

    def decode(self, x_norm: np.ndarray) -> np.ndarray:
        x_norm_clipped = np.clip(x_norm, 0, 1)
        return self.lower + x_norm_clipped * self.range

# ===================================================================
# 【全新】为问题三设计的、支持“约束保持”参数化的包装器
# ===================================================================
class CostFunctionWrapperQ3(CostFunctionWrapper):
    def __init__(self, cost_function, lower_bounds, upper_bounds):
        super().__init__(cost_function, lower_bounds, upper_bounds)
        self.min_interval = Config.MIN_LAUNCH_INTERVAL

    def __call__(self, x_norm: np.ndarray) -> float:
        x_norm_clipped = np.clip(x_norm, 0, 1)
        x_physical = self.lower + x_norm_clipped * self.range
      
        # 解码增量参数
        v, th, t_start, delta_12, delta_23, dt1, dt2, dt3 = x_physical
      
        # 【关键】通过构造法保证约束
        t1 = t_start
        t2 = t1 + self.min_interval + delta_12
        t3 = t2 + self.min_interval + delta_23
      
        # 将构造好的参数传入原始代价函数
        # 注意：原始代价函数现在不需要再检查约束了
        return self.cost_function(np.array([v, th, t1, t2, t3, dt1, dt2, dt3]))

    def decode(self, x_norm: np.ndarray) -> np.ndarray:
        x_norm_clipped = np.clip(x_norm, 0, 1)
        x_physical = self.lower + x_norm_clipped * self.range
      
        v, th, t_start, delta_12, delta_23, dt1, dt2, dt3 = x_physical
      
        t1 = t_start
        t2 = t1 + self.min_interval + delta_12
        t3 = t2 + self.min_interval + delta_23
      
        return np.array([v, th, t1, t2, t3, dt1, dt2, dt3])

# ===================================================================
# 问题一求解器 (保持不变)
# ===================================================================
def solve_problem_1():
    # ... (代码完全不变，此处省略) ...
    """问题一：固定策略下的遮蔽时长计算（使用鲁棒解析法）。"""
    print("\n--- 开始求解问题 1 (鲁棒解析法精确计算) ---")
    cfg = Config()
  
    v_uav_speed = 120.0
    t_launch = 1.5
    dt_det = 3.6
  
    uav_pos_0 = cfg.UAV_INITIAL_POS['FY1']
    uav_dir = (cfg.P_FALSE_TARGET[:2] - uav_pos_0[:2])
    uav_dir /= np.linalg.norm(uav_dir)
    v_vec_uav = np.array([uav_dir[0], uav_dir[1], 0]) * v_uav_speed
  
    p_launch = uav_pos_0 + v_vec_uav * t_launch
    p_det = p_launch + v_vec_uav * dt_det + 0.5 * np.array([0, 0, -cfg.G]) * dt_det**2
    t_det = t_launch + dt_det

    model = PhysicsModelAnalytical(missile_id='M1', uav_id='FY1')
    metrics = model.calculate_shielding_metrics(p_det, t_det)
  
    print("计算完成！")
    print(f"烟幕起爆时刻: {t_det:.4f} s")
    print(f"烟幕起爆位置: {np.round(p_det, 2)}")
    print(f"有效遮蔽时间区间: {[(round(s, 4), round(e, 4)) for s, e in metrics['intervals']]}")
    print(f"总有效遮蔽时长: {metrics['total_time']:.8f} s")
    return {"total_shielding_time": metrics['total_time']}

# ===================================================================
# 问题二和三的最终版求解器
# ===================================================================

def solve_problem_2_advanced():
    """问题二：高级优化策略。"""
    print("\n--- 开始求解问题 2 (高级策略: 正规化 + 重启 + 精调) ---")
    model = PhysicsModelAnalytical(missile_id='M1', uav_id='FY1')
  
    lower_bounds = [model.config.V_UAV_MIN, 0, 0.1, 0.1]
    upper_bounds = [model.config.V_UAV_MAX, 2 * np.pi, model.time_to_impact - 25, 20.0]
  
    wrapped_cost_func = CostFunctionWrapper(model.cost_function_q2, lower_bounds, upper_bounds)

    global_best_solution_norm = None
    global_best_cost = float('inf')

    num_restarts = 3
    total_evals = 15000 # 增加评估次数
    evals_per_restart = total_evals // num_restarts

    for i in range(num_restarts):
        print(f"\n--- 第 {i+1}/{num_restarts} 轮重启 ---")
        initial_guess_norm = np.random.rand(4)
        sigma0 = 0.3 # 稍大一点的初始步长，鼓励探索
        options = {'bounds': [0, 1], 'maxfevals': evals_per_restart, 'popsize': 30, 'verbose': -9}
      
        es = cma.CMAEvolutionStrategy(initial_guess_norm, sigma0, options)
      
        while not es.stop():
            solutions_norm = es.ask()
            costs = [wrapped_cost_func(s) for s in solutions_norm]
            es.tell(solutions_norm, costs)
          
            if es.countiter % 20 == 0:
                print(f"  轮次 {i+1} | 迭代 {es.countiter:4d} | 评估数 {es.countevals:5d} | 当前最优成本: {es.result.fbest:9.4f} | 步长: {es.sigma:.6f}")

        if es.result.fbest < global_best_cost:
            global_best_cost = es.result.fbest
            global_best_solution_norm = es.result.xbest
            print(f"*** 发现新的全局最优解！成本: {global_best_cost:.4f} ***")

    best_solution_physical = wrapped_cost_func.decode(global_best_solution_norm)
    final_time = -model.cost_function_q2(best_solution_physical) # 使用原始cost func做最终验证

    print("\n" + "="*50)
    print("优化完成！")
    v, th, t_l, dt_d = best_solution_physical
    print(f"最优策略: 速度={v:.2f} m/s, 方向={np.rad2deg(th):.2f}°, 投放时间={t_l:.2f}s, 延迟={dt_d:.2f}s")
    print(f"最终精确验证的最大遮蔽时长: {final_time:.4f} s")
    print("="*50)
    return {"max_shielding_time": final_time, "best_solution": best_solution_physical}


def solve_problem_3_advanced():
    """问题三：高级优化策略 (使用约束保持参数化)。"""
    print("\n--- 开始求解问题 3 (高级策略: 约束保持 + 正规化 + 重启) ---")
    model = PhysicsModelAnalytical(missile_id='M1', uav_id='FY1')

    # 【关键】定义新的、基于增量的参数边界
    # 优化变量: [v, th, t_start, delta_12, delta_23, dt1, dt2, dt3]
    lower_bounds = [model.config.V_UAV_MIN, 0, 0.1, 0.0, 0.0, 0.1, 0.1, 0.1]
    # t_start + (1+d12) + (1+d23) < T_impact
    # 粗略估计上界，给足探索空间
    upper_bounds = [model.config.V_UAV_MAX, 2*np.pi, 40.0, 15.0, 15.0, 20.0, 20.0, 20.0]
  
    # 使用新的Q3包装器
    wrapped_cost_func = CostFunctionWrapperQ3(model.cost_function_q3, lower_bounds, upper_bounds)

    global_best_solution_norm = None
    global_best_cost = float('inf')

    num_restarts = 5
    total_evals = 60000 # 增加总评估次数
    evals_per_restart = total_evals // num_restarts

    for i in range(num_restarts):
        print(f"\n--- 第 {i+1}/{num_restarts} 轮重启 ---")
        initial_guess_norm = np.random.rand(8)
        sigma0 = 0.3
        options = {'bounds': [0, 1], 'maxfevals': evals_per_restart, 'popsize': 40, 'verbose': -9}
      
        es = cma.CMAEvolutionStrategy(initial_guess_norm, sigma0, options)
      
        while not es.stop():
            solutions_norm = es.ask()
            costs = [wrapped_cost_func(s) for s in solutions_norm]
            es.tell(solutions_norm, costs)
          
            if es.countiter % 20 == 0:
                print(f"  轮次 {i+1} | 迭代 {es.countiter:4d} | 评估数 {es.countevals:5d} | 当前最优成本: {es.result.fbest:9.4f} | 步长: {es.sigma:.6f}")

        if es.result.fbest < global_best_cost:
            global_best_cost = es.result.fbest
            global_best_solution_norm = es.result.xbest
            print(f"*** 发现新的全局最优解！成本: {global_best_cost:.4f} ***")

    best_solution_physical = wrapped_cost_func.decode(global_best_solution_norm)
    # 最终验证时，也需要用包装器来解码，然后用原始函数计算
    final_time = -wrapped_cost_func(global_best_solution_norm)

    print("\n" + "="*50)
    print("优化完成！")
    v, th, t1, t2, t3, dt1, dt2, dt3 = best_solution_physical
    print(f"最优策略: 速度={v:.2f} m/s, 方向={np.rad2deg(th):.2f}°")
    print(f"  烟幕弹 1: 投放时间={t1:.2f}s, 延迟={dt1:.2f}s")
    print(f"  烟幕弹 2: 投放时间={t2:.2f}s, 延迟={dt2:.2f}s")
    print(f"  烟幕弹 3: 投放时间={t3:.2f}s, 延迟={dt3:.2f}s")
    print(f"最终精确验证的最大遮蔽时长: {final_time:.4f} s")
    print("="*50)
    return {"max_shielding_time": final_time, "best_solution": best_solution_physical}

```

### **需要同步修改 `analytical_model.py`**

为了配合问题三的新参数化，我们需要对 `analytical_model.py`中的 `cost_function_q3`做一个小小的修改，**移除**里面的约束检查，因为它现在由包装器在外部保证了。

```python
# analytical_model.py (修改 cost_function_q3)

# ... (其他部分不变) ...
class PhysicsModelAnalytical:
    # ...
    def cost_function_q3(self, x: np.ndarray) -> float:
        """问题三的代价函数：单无人机，三弹药。"""
        v_uav, theta_uav, t1, t2, t3, dt1, dt2, dt3 = x
      
        # 【关键修改】移除约束检查，因为它现在由外部的 CostFunctionWrapperQ3 保证
        # if not (t2 >= t1 + self.config.MIN_LAUNCH_INTERVAL and ...):
        #     ...
      
        v_vec_uav = np.array([v_uav * np.cos(theta_uav), v_uav * np.sin(theta_uav), 0])
        launch_times = [t1, t2, t3]
        det_delays = [dt1, dt2, dt3]
      
        all_intervals = []
        total_proxy_penalty = 0.0

        for t_launch, dt_det in zip(launch_times, det_delays):
            p_launch = self.p_uav_0 + v_vec_uav * t_launch
            p_det = p_launch + v_vec_uav * dt_det + 0.5 * np.array([0, 0, -self.config.G]) * dt_det**2
            t_det = t_launch + dt_det
          
            metrics = self.calculate_shielding_metrics(p_det, t_det)
            all_intervals.extend(metrics["intervals"])
            total_proxy_penalty += metrics["proxy_cost"]

        merged = self._merge_intervals(all_intervals)
        total_time = sum(end - start for start, end in merged)
      
        return -total_time + self.config.REWARD_SHAPING_PENALTY_FACTOR * total_proxy_penalty
```

### **总结**

这次升级是决定性的。通过：

1. **增强奖励因子**，我们让问题二的优化器能够找到正确的方向。
2. **引入约束保持参数化**，我们从根本上解决了问题三的“雷区”困境，让优化器可以在一个干净、无约束的有效空间内自由翱翔。

现在，您的求解器已经武装到了牙齿。再次运行 `main.py`，您将会
